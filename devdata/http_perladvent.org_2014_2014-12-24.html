<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <meta http-equiv="Content-Language" content="en" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="generator" content="WWW::AdventCalendar v1.109" />
    <link rel="alternate" title="Perl Advent Calendar 2014 XML feed" href="atom.xml" type="application/atom+xml" />
    <link rel="shortcut icon" href="favicon.ico" />
    <link rel="stylesheet" href="style.css" type="text/css" />
    <link rel="stylesheet" href="2014.css" type="text/css" />
    <title>
Perl Advent Calendar 2014 - 
Out of Order Perl

</title>
</head>
<body>
    <div id="contentwrapper">
        <div id="header">
            <h1><a href="index.html">Perl Advent Calendar 2014</a></h1>
        </div>

        <p id="tagline">twenty four merry days of Perl
          <a class='feed' href="atom.xml">Feed</a>
        </p>

        <div id="content">
          

<h1 class='title'>Out of Order Perl</h1>
<div class='subtitle'>AnyEvent - 2014-12-24</div>

<div class='pod'><p>This article will cover asynchronous programming with the AnyEvent library and will show use cases for managing multiple asynchronous requests in a single application. In addition, I hope to introduce good techniques for using metrics to drive technology decisions!</p>

<h3 id="Is-an-Asynchronous-Solution-right-for-me">Is an Asynchronous Solution right for me?</h3>

<p>New software techniques and practices are always rearing their heads in the industry. While asynchronous functionality is not new to Perl, it is not widely used where it could be, and maybe over-used where it shouldn&#39;t be. When considering whether or not to adopt some new methodology on existing software, it&#39;s important to make sure you have clearly identified what problem you are trying to solve. It&#39;s fine if you want to play around with something new, but remember that every solution has a cost. The cost of asynchronous functionality is that it can be difficult to read and debug (callback soup anyone?) and you have to consider compatibility of your current web framework as well as your current code base.</p>

<h4 id="Step-1:-Identify-the-Problem">Step 1: Identify the Problem</h4>



<blockquote>â70% of users are unable to download the TPS Report from the website because the
website times out.â</blockquote>



<blockquote>âWeb site latency is reported for 75% of users.â</blockquote>

<h4 id="Step-2:-Identify-the-cause-the-clarify-the-problem-with-numbers">Step 2: Identify the cause the clarify the problem (with numbers!)</h4>

<p>To identify the cause, you can check logs, collect metrics (a lot of folks use statsd), or attempt to reproduce the problem in a staging environment.</p>



<blockquote>âThe TPS report database query takes 30 seconds to runâ</blockquote>



<blockquote>âRequests to HTTP services are averaging 1 second because each request is made individually and is only made once the previous request is complete.â</blockquote>

<h4 id="Step-3:-Propose-a-solution-based-on-data-and-facts">Step 3: Propose a solution (based on data and facts)</h4>

<p>Now that you&#39;ve collected data and clarified your problem in terms of metrics, you can say &quot;Asynchronous HTTP requests would reduce overall report loading time to only the amount of time it takes the longest request to return.&quot;</p>

<p>Implement a Solution based on your results... and use metrics to determine success There is a fully functioning sample application! The sample application from which the code snippets in this article come is located on <a href="http://github.com/missaugustina/perl-out-of-order">github</a>.</p>

<p>The sample application is a simple Mojolicious::Lite application the generates a &ldquo;TPS&rdquo; report. This report makes calls to 2 external services to collect data and then uses that data to make a complex call to the database. I&#39;m just using simple timing metrics to show the results for each of the reports. You can run it yourself to see the results as it records them in the database. First Improvement: Make it Async!</p>

<p>As we ascertained from our problem statement exercise just now, kicking off HTTP requests at the same time would drastically improve our report&#39;s performance.</p>

<p>Here&#39;s how you currently use LWP to make HTTP requests:</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;<br />6:&nbsp;<br />7:&nbsp;<br />8:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="keyword">my</span> <span class="symbol">$ua</span> <span class="operator">=</span> <span class="word">LWP::UserAgent</span><span class="operator">-&gt;</span><span class="word">new</span><span class="structure">();</span><br /><span class="keyword">my</span> <span class="symbol">$req</span> <span class="operator">=</span> <span class="word">HTTP::Request</span><span class="operator">-&gt;</span><span class="word">new</span><span class="structure">(</span> <span class="word">GET</span> <span class="operator">=&gt;</span> <span class="symbol">$url</span> <span class="structure">);</span><br /><br /><span class="comment"># make the request, and wait until we get the results back<br /></span><span class="keyword">my</span> <span class="symbol">$res</span> <span class="operator">=</span> <span class="symbol">$ua</span><span class="operator">-&gt;</span><span class="word">request</span><span class="structure">(</span><span class="symbol">$req</span><span class="structure">);</span><br /><br /><span class="keyword">my</span> <span class="symbol">$content</span> <span class="operator">=</span> <span class="symbol">$res</span><span class="operator">-&gt;</span><span class="word">content</span><span class="structure">;</span><br /><span class="keyword">return</span> <span class="symbol">$content</span><span class="structure">;</span></code><br />&nbsp;</td></table>

<p>Here&#39;s how it looks in our sample application:</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;<br />6:&nbsp;<br />7:&nbsp;<br />8:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="keyword">while</span> <span class="structure">(</span><span class="keyword">my</span> <span class="structure">(</span><span class="symbol">$service_name</span><span class="operator">,</span> <span class="symbol">$url</span><span class="structure">)</span> <span class="operator">=</span> <span class="structure">(</span><span class="word">each</span> <span class="cast">%</span><span class="structure">{</span><span class="symbol">$self</span><span class="operator">-&gt;</span><span class="word">urls</span><span class="structure">}))</span> <span class="structure">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">my</span> <span class="symbol">$req</span> <span class="operator">=</span> <span class="word">HTTP::Request</span><span class="operator">-&gt;</span><span class="word">new</span><span class="structure">(</span> <span class="word">GET</span> <span class="operator">=&gt;</span> <span class="symbol">$url</span> <span class="structure">);</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">my</span> <span class="symbol">$res</span> <span class="operator">=</span> <span class="symbol">$self</span><span class="operator">-&gt;</span><span class="word">_user_agent</span><span class="operator">-&gt;</span><span class="word">request</span><span class="structure">(</span><span class="symbol">$req</span><span class="structure">);</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">my</span> <span class="symbol">$content</span> <span class="operator">=</span> <span class="symbol">$res</span><span class="operator">-&gt;</span><span class="word">content</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="symbol">$http_data</span><span class="operator">-&gt;</span><span class="structure">{</span><span class="symbol">$service_name</span><span class="structure">}</span> <span class="operator">=</span> <span class="symbol">$content</span><span class="structure">;</span><br /><span class="structure">}</span><br />&nbsp;&nbsp;<br /><span class="keyword">return</span> <span class="symbol">$http_data</span><span class="structure">;</span></code><br />&nbsp;</td></table>

<p>Notice that these requests happen for EACH URL in our list for EACH row in the database results one after the other, waiting for the previous request to return before starting the next. If we have 10 URLs and each one takes 3 milliseconds, our total request takes 10 x 3 milliseconds or 30 milliseconds total. If one of them takes any more time than that, it will hold up processing of the others and makes our request take even longer.</p>

<p>There are a lot of asynchronous libraries in the CPAN for you to consider. I&#39;m using AnyEvent because we&#39;re going to be talking to RabbitMQ later and AnyEvent::RabbitMQ is one of the better libraries for doing that. When considering what asynchronous library to use, you always need to think about your requirements and to determine if it&#39;s likely you&#39;ll be adding other asynchronous functionality. Swapping one out for another, however, isn&#39;t impossible as they all pretty much follow the same rules (they just call things by different names). What you&#39;ll learn here about how to use AnyEvent will also apply in concept to any other library you might want to use instead.</p>

<p>Here&#39;s what the asynchronous solution looks like in our sample application using AnyEvent::HTTP.</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;<br />6:&nbsp;<br />7:&nbsp;<br />8:&nbsp;<br />9:&nbsp;<br />10:&nbsp;<br />11:&nbsp;<br />12:&nbsp;<br />13:&nbsp;<br />14:&nbsp;<br />15:&nbsp;<br />16:&nbsp;<br />17:&nbsp;<br />18:&nbsp;<br />19:&nbsp;<br />20:&nbsp;<br />21:&nbsp;<br />22:&nbsp;<br />23:&nbsp;<br />24:&nbsp;<br />25:&nbsp;<br />26:&nbsp;<br />27:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="keyword">my</span> <span class="symbol">$cv</span> <span class="operator">=</span> <span class="word">AnyEvent</span><span class="operator">-&gt;</span><span class="word">condvar</span><span class="structure">;</span><br />&nbsp;&nbsp;<br /><span class="keyword">my</span> <span class="symbol">$result</span><span class="structure">;</span><br /><br /><span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">begin</span><span class="structure">(</span><span class="keyword">sub</span> <span class="structure">{</span> <span class="core">shift</span><span class="operator">-&gt;</span><span class="word">send</span><span class="structure">(</span><span class="symbol">$result</span><span class="structure">)</span> <span class="structure">});</span><br /><br /><span class="keyword">while</span> <span class="structure">(</span><span class="keyword">my</span> <span class="structure">(</span><span class="symbol">$service_name</span><span class="operator">,</span> <span class="symbol">$url</span><span class="structure">)</span> <span class="operator">=</span> <span class="structure">(</span><span class="word">each</span> <span class="cast">%</span><span class="structure">{</span><span class="symbol">$self</span><span class="operator">-&gt;</span><span class="word">urls</span><span class="structure">}))</span> <span class="structure">{</span><br />&nbsp;&nbsp;<span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">begin</span><span class="structure">;</span><br /><br />&nbsp;&nbsp;<span class="keyword">my</span> <span class="symbol">$request</span><span class="structure">;</span><br />&nbsp;&nbsp;<br />&nbsp;&nbsp;<span class="symbol">$request</span> <span class="operator">=</span> <span class="word">http_request</span><span class="structure">(</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">GET</span> <span class="operator">=&gt;</span> <span class="symbol">$url</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">timeout</span> <span class="operator">=&gt;</span> <span class="number">2</span><span class="operator">,</span> <span class="comment"># seconds</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">sub</span> <span class="structure">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">my</span> <span class="structure">(</span><span class="symbol">$content</span><span class="operator">,</span> <span class="symbol">$headers</span><span class="structure">)</span> <span class="operator">=</span> <span class="magic">@_</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="symbol">$result</span><span class="operator">-&gt;</span><span class="structure">{</span><span class="symbol">$service_name</span><span class="structure">}</span> <span class="operator">=</span> <span class="symbol">$content</span><span class="structure">;</span><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="core">undef</span> <span class="symbol">$request</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">end</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">}</span><br />&nbsp;&nbsp;<span class="structure">);</span><br /><span class="structure">}</span><br /><br /><span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">end</span><span class="structure">;</span><br /><br /><span class="keyword">return</span> <span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">recv</span><span class="structure">;</span></code><br />&nbsp;</td></table>

<p>Let&#39;s add a few more comments to try and make it a little clearer what&#39;s going on:</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;<br />6:&nbsp;<br />7:&nbsp;<br />8:&nbsp;<br />9:&nbsp;<br />10:&nbsp;<br />11:&nbsp;<br />12:&nbsp;<br />13:&nbsp;<br />14:&nbsp;<br />15:&nbsp;<br />16:&nbsp;<br />17:&nbsp;<br />18:&nbsp;<br />19:&nbsp;<br />20:&nbsp;<br />21:&nbsp;<br />22:&nbsp;<br />23:&nbsp;<br />24:&nbsp;<br />25:&nbsp;<br />26:&nbsp;<br />27:&nbsp;<br />28:&nbsp;<br />29:&nbsp;<br />30:&nbsp;<br />31:&nbsp;<br />32:&nbsp;<br />33:&nbsp;<br />34:&nbsp;<br />35:&nbsp;<br />36:&nbsp;<br />37:&nbsp;<br />38:&nbsp;<br />39:&nbsp;<br />40:&nbsp;<br />41:&nbsp;<br />42:&nbsp;<br />43:&nbsp;<br />44:&nbsp;<br />45:&nbsp;<br />46:&nbsp;<br />47:&nbsp;<br />48:&nbsp;<br />49:&nbsp;<br />50:&nbsp;<br />51:&nbsp;<br />52:&nbsp;<br />53:&nbsp;<br />54:&nbsp;<br />55:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="comment"># A condition variable.  Basically a mechanism to tell if we're done<br /># processing all the requests or not.<br /></span><span class="keyword">my</span> <span class="symbol">$cv</span> <span class="operator">=</span> <span class="word">AnyEvent</span><span class="operator">-&gt;</span><span class="word">condvar</span><span class="structure">;</span><br /><br /><span class="keyword">my</span> <span class="symbol">$result</span><span class="structure">;</span><br /><br /><span class="comment"># tell the condition variable that it's not &quot;ready&quot; until it sees the &quot;end&quot;<br /># call at the end of the code signifying we're done setting up all the<br /># requests.  This is good practice to avoid accidentally completing<br /># while we're still setting up all the requests.<br />#<br /># Also pass the code block that will be executed at this point when the<br /># condition variable is &quot;ready&quot;.<br /></span><span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">begin</span><span class="structure">(</span><span class="keyword">sub</span> <span class="structure">{</span> <span class="core">shift</span><span class="operator">-&gt;</span><span class="word">send</span><span class="structure">(</span><span class="symbol">$result</span><span class="structure">)</span> <span class="structure">});</span><br /><br /><span class="comment"># for each of our urls, start a request in parallel<br /></span><span class="keyword">while</span> <span class="structure">(</span><span class="keyword">my</span> <span class="structure">(</span><span class="symbol">$service_name</span><span class="operator">,</span> <span class="symbol">$url</span><span class="structure">)</span> <span class="operator">=</span> <span class="structure">(</span><span class="word">each</span> <span class="cast">%</span><span class="structure">{</span><span class="symbol">$self</span><span class="operator">-&gt;</span><span class="word">urls</span><span class="structure">}))</span> <span class="structure">{</span><br /><br /><span class="comment">  # add another thing to the list of things that must be completed<br />&nbsp;&nbsp;# before the condition variable is &quot;ready&quot;.  i.e. let the condition variable<br />&nbsp;&nbsp;# know that we must wait until the HTTP request returns and the callback<br />&nbsp;&nbsp;# calls a corresponding &quot;end&quot; on the condition variable before we're done.<br /></span>  <span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">begin</span><span class="structure">;</span><br />&nbsp;&nbsp;<br /><span class="comment">  # schedule a HTTP request to made asynchronously.  Once it's done<br />&nbsp;&nbsp;# and we've got the content, call the callback.<br /></span>  <span class="keyword">my</span> <span class="symbol">$request</span><span class="structure">;</span><br />&nbsp;&nbsp;<span class="symbol">$request</span> <span class="operator">=</span> <span class="word">http_request</span><span class="structure">(</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">GET</span> <span class="operator">=&gt;</span> <span class="symbol">$url</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">timeout</span> <span class="operator">=&gt;</span> <span class="number">2</span><span class="operator">,</span> <span class="comment"># seconds</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">sub</span> <span class="structure">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">my</span> <span class="structure">(</span><span class="symbol">$content</span><span class="operator">,</span> <span class="symbol">$headers</span><span class="structure">)</span> <span class="operator">=</span> <span class="magic">@_</span><span class="structure">;</span><br /><br /><span class="comment">      # save the content for this request (i.e. what we downloaded) in our<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# result<br /></span>      <span class="symbol">$result</span><span class="operator">-&gt;</span><span class="structure">{</span><span class="symbol">$service_name</span><span class="structure">}</span> <span class="operator">=</span> <span class="symbol">$content</span><span class="structure">;</span><br /><br /><span class="comment">      # clean ourselves up<br /></span>      <span class="core">undef</span> <span class="symbol">$request</span><span class="structure">;</span><br /><br /><span class="comment">      # and let the condition variable know that this scheduled thing<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# is done and once the last one is done it can fire.<br /></span>      <span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">end</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">}</span><br />&nbsp;&nbsp;<span class="structure">);</span><br /><span class="structure">}</span><br /><br /><span class="comment"># signify that we're done with stage of setting up all the requests.  The<br /># condition variable become &quot;ready&quot; until all the requests that called &quot;begin&quot;<br /># above have also completed and called a corresponding number of &quot;end&quot; calls<br /></span><span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">end</span><span class="structure">;</span><br /><br /><span class="comment"># wait (i.e. block) until the condition variable is ready, i.e. until a<br /># corresponding number of &quot;end&quot; calls have been called for each &quot;begin&quot; call<br /></span><span class="keyword">return</span> <span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">recv</span><span class="structure">;</span></code><br />&nbsp;</td></table>

<p>We&#39;ll get back to this code, explaining in more depth each section of code bit by bit once we&#39;ve learned a little more about AnyEvent.</p>

<p>First, let&#39;s look at the advantage of using this significantly more complicated code. With an asynchronous solution, if each request takes 3 milliseconds, then we get our results back in 3 milliseconds. If one of those requests takes 1 second, then we get all of our results back in 1 second. The time it takes to get our results back takes only as long as the longest request!</p>

<h3 id="What-does-it-mean-to-be-Asynchronous">What does it mean to be Asynchronous?</h3>

<h4 id="Asynchronous-code-is-event-driven">Asynchronous code is event-driven</h4>

<p>An event queue manages code execution. If you&#39;ve ever had to do any work with user interfaces, you should be familiar with the notion of an event-listener. An event in a user interface would be a button click. You would register a function to execute when the the button is pushed. In our example, the function (callback) we&#39;ve registered with the event we&#39;re interested in is pushed to an event queue that fires after all the other code executes. The event loop is a queue of callback functions. When an asynchronous function executes, the callback function is pushed into the event queue.</p>

<h4 id="Results-are-returned-in-the-background-while-your-application-does-other-things">Results are returned in the background while your application does other things</h4>

<p>The rest of your application proceeds ahead using a placeholder for the result until it reaches a point where it can&#39;t go any further without the actual result (for example writing that result out to a data store).</p>

<p>The basic formula for Async: <b>Event Loop + Listener + Callbacks</b></p>

<p>A listener registers your interest in a particular event. A callback is a function that runs when your request is in a <i>ready</i> state. No matter what Async library you use, all of them follow these rules.</p>

<p>Now we&#39;ll talk about more specifically what this looks like in the AnyEvent libraries.</p>

<h3 id="AnyEvent-101">AnyEvent 101</h3>

<h4 id="condvar"><code>condvar</code></h4>

<p>AnyEvent is just an abstraction layer on top of event loops. The <code>condvar()</code> method initializes the condition variable which represents a value that may or may not be available. The condition variable doesn&#39;t have a value until it is &ldquo;ready&rdquo;, meaning the request has completed. You use the <code>condvar()</code> method to interface with the event loop.</p>

<h4 id="send"><code>send</code></h4>

<p>The <code>send()</code> method sets the conditional variable to <i>ready</i>. This will indicate that one event is complete. In the case of multiple requests, you can bind a callback to <code>send()</code> so that you can store the values retrieved each time the condvar is in a ready state.</p>

<h4 id="recv"><code>recv</code></h4>

<p>This returns a value when the <code>condvar</code> is in a ready state. Note that this is blocking because this is called at the point where your program cannot continue until it has the value it needs. I&#39;ll show why this is important later when we introduce RabbitMQ and have to manage multiple asynchronous requests.</p>

<h4 id="begin-and-end"><code>begin</code> and <code>end</code></h4>

<p>These methods are syntactic sugar for using a counter within an event loop. Begin increments the counter and end decrements it. The event loops runs until the counter is at 0. You can use these methods when you&#39;re managing multiple requests within an event loop and you want to make sure the event loop doesn&#39;t terminate until all of the requests you want have finished.</p>

<p>If you were to implement this yourself, you could create a loop where you create a <code>condvar</code> for each individual request. This syntactic sugar lets you declare just one &lt;Ccondvar&gt; and then specify when you want to set its ready state so <code>recv</code> can return the result.</p>

<h3 id="AnyEvent::HTTP-Code-Walkthrough">AnyEvent::HTTP Code Walkthrough</h3>

<p>Remember that code sample from earlier? Well now that we have a little better vocabulary, we can walk through it and understand what&#39;s happening in a little more detail, and hopefully understand how we came to write the code like that.</p>

<p>The first step is to initialize the <code>condvar</code>. Remember at this point, it has no actual value!</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="keyword">my</span> <span class="symbol">$cv</span> <span class="operator">=</span> <span class="word">AnyEvent</span><span class="operator">-&gt;</span><span class="word">condvar</span><span class="structure">;</span></code><br />&nbsp;</td></table>

<p>Next, you need to determine what you want to return at the <i>ready</i> state and assign it. This is where async programming can get a little tricky (hence the title of this article)! You need to think backwards when you start thinking async. Think from the result and work your way back. Decide at what point your application absolutely needs this data and put your <code>recv</code> call there.</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="operator">...</span><span class="word">all</span> <span class="word">the</span> <span class="word">other</span> <span class="word">code</span><span class="operator">...</span><br /><span class="keyword">return</span> <span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">recv</span><span class="structure">;</span></code><br />&nbsp;</td></table>

<p>Now all we need to work out what code goes between these two statements. We need to figure out when to call the send event so we can capture our result. We&#39;re going to call it within a callback bound to a begin call. Each time we want to fetch data from a URL, we&#39;ll increment our event loop counter so that we don&#39;t exit out of the event loop before we&#39;ve gotten a response for each of our URL requests. So, this means, in English: Once all the URLs are fetched, set the <code>condvar</code> to ready and return the result.</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="keyword">my</span> <span class="symbol">$cv</span> <span class="operator">=</span> <span class="word">AnyEvent</span><span class="operator">-&gt;</span><span class="word">condvar</span><span class="structure">;</span><br /><span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">begin</span><span class="structure">(</span><span class="keyword">sub</span> <span class="structure">{</span> <span class="core">shift</span><span class="operator">-&gt;</span><span class="word">send</span><span class="structure">(</span><span class="symbol">$result</span><span class="structure">)</span> <span class="structure">});</span>   <span class="comment"># &lt;------------- we add this</span><br /><span class="operator">...</span><br /><span class="keyword">return</span> <span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">recv</span><span class="structure">;</span></code><br />&nbsp;</td></table>

<p>Because we&#39;ve declared a begin, we need to declare an end outside of the loop to ensure that send gets called. If our loop has no data (in the while block) we would loop forever without this call to end here. This ensures the send we registered with our begin up above gets called.</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="keyword">my</span> <span class="symbol">$cv</span> <span class="operator">=</span> <span class="word">AnyEvent</span><span class="operator">-&gt;</span><span class="word">condvar</span><span class="structure">;</span><br /><span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">begin</span><span class="structure">(</span><span class="keyword">sub</span> <span class="structure">{</span> <span class="core">shift</span><span class="operator">-&gt;</span><span class="word">send</span><span class="structure">(</span><span class="symbol">$result</span><span class="structure">)</span> <span class="structure">});</span><br /><span class="operator">...</span><br /><span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">end</span><span class="structure">;</span>                                   <span class="comment"># &lt;------------- we add this</span><br /><span class="keyword">return</span> <span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">recv</span><span class="structure">;</span></code><br />&nbsp;</td></table>

<p>Now that we&#39;ve defined our start and end points, we can focus on the actual logic around retrieving the URLs. We&#39;re going to use the AnyEvent::HTTP library, in particular the <code>http_request</code> method. Calling <code>http_request</code> means that you want the request to be made whenever it&#39;s possible (versus a procedural call which would mean stop everything and do it right now). This registers an IO watcher and tells the event loop that we are interested in this IO event.</p>

<p>When the request finishes, we want to invoke the callback that we&#39;ve bound to the function call.</p>

<p>This method doesn&#39;t actually do the request, it returns right away and tells the event loop to do the request whenever it can. When this chunk of code runs, the event loop is not running because this chunk of code has control.</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;<br />6:&nbsp;<br />7:&nbsp;<br />8:&nbsp;<br />9:&nbsp;<br />10:&nbsp;<br />11:&nbsp;<br />12:&nbsp;<br />13:&nbsp;<br />14:&nbsp;<br />15:&nbsp;<br />16:&nbsp;<br />17:&nbsp;<br />18:&nbsp;<br />19:&nbsp;<br />20:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="keyword">my</span> <span class="symbol">$cv</span> <span class="operator">=</span> <span class="word">AnyEvent</span><span class="operator">-&gt;</span><span class="word">condvar</span><span class="structure">;</span><br /><span class="keyword">my</span> <span class="symbol">$result</span><span class="structure">;</span>   <br /><span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">begin</span><span class="structure">(</span><span class="keyword">sub</span> <span class="structure">{</span> <span class="core">shift</span><span class="operator">-&gt;</span><span class="word">send</span><span class="structure">(</span><span class="symbol">$result</span><span class="structure">)</span> <span class="structure">});</span><br /><br /><span class="keyword">while</span> <span class="structure">(</span><span class="keyword">my</span> <span class="structure">(</span><span class="symbol">$service_name</span><span class="operator">,</span> <span class="symbol">$url</span><span class="structure">)</span> <span class="operator">=</span> <span class="structure">(</span><span class="word">each</span> <span class="cast">%</span><span class="structure">{</span><span class="symbol">$self</span><span class="operator">-&gt;</span><span class="word">urls</span><span class="structure">}))</span> <span class="structure">{</span><br />&nbsp;&nbsp;<span class="operator">...</span><br />&nbsp;&nbsp;<span class="word">my</span> <span class="symbol">$request</span><span class="structure">;</span>                                <span class="operator">&lt;----</span><br />&nbsp;&nbsp;<span class="symbol">$request</span> <span class="operator">=</span> <span class="word">http_request</span><span class="structure">(</span>                    <span class="readline">&lt;----<br />&nbsp;&nbsp;&nbsp;&nbsp;GET =&gt;</span> <span class="symbol">$url</span><span class="operator">,</span>                              <span class="readline">&lt;----    we add<br />&nbsp;&nbsp;&nbsp;&nbsp;timeout =&gt;</span> <span class="number">2</span><span class="operator">,</span> <span class="comment"># seconds                   &lt;----    all of</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">sub</span> <span class="structure">{</span>                                     <span class="operator">&lt;----</span>    <span class="word">this</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">my</span> <span class="structure">(</span><span class="symbol">$content</span><span class="operator">,</span> <span class="symbol">$headers</span><span class="structure">)</span> <span class="operator">=</span> <span class="magic">@_</span><span class="structure">;</span>           <span class="operator">&lt;----</span>    <span class="word">code</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="symbol">$result</span><span class="operator">-&gt;</span><span class="structure">{</span><span class="symbol">$service_name</span><span class="structure">}</span> <span class="operator">=</span> <span class="symbol">$content</span><span class="structure">;</span>    <span class="operator">&lt;----</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="operator">...</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">}</span>                                         <span class="operator">&lt;----</span><br />&nbsp;&nbsp;<span class="structure">);</span>                                          <span class="operator">&lt;----</span><br /><span class="structure">}</span><br /><br /><span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">end</span><span class="structure">;</span><br /><span class="keyword">return</span> <span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">recv</span><span class="structure">;</span></code><br />&nbsp;</td></table>

<p>We need to unregister our interest in this event once we&#39;re done with it.</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;<br />6:&nbsp;<br />7:&nbsp;<br />8:&nbsp;<br />9:&nbsp;<br />10:&nbsp;<br />11:&nbsp;<br />12:&nbsp;<br />13:&nbsp;<br />14:&nbsp;<br />15:&nbsp;<br />16:&nbsp;<br />17:&nbsp;<br />18:&nbsp;<br />19:&nbsp;<br />20:&nbsp;<br />21:&nbsp;<br />22:&nbsp;<br />23:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="keyword">my</span> <span class="symbol">$cv</span> <span class="operator">=</span> <span class="word">AnyEvent</span><span class="operator">-&gt;</span><span class="word">condvar</span><span class="structure">;</span><br /><span class="keyword">my</span> <span class="symbol">$result</span><span class="structure">;</span>   <br /><span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">begin</span><span class="structure">(</span><span class="keyword">sub</span> <span class="structure">{</span> <span class="core">shift</span><span class="operator">-&gt;</span><span class="word">send</span><span class="structure">(</span><span class="symbol">$result</span><span class="structure">)</span> <span class="structure">});</span><br /><br /><span class="keyword">while</span> <span class="structure">(</span><span class="keyword">my</span> <span class="structure">(</span><span class="symbol">$service_name</span><span class="operator">,</span> <span class="symbol">$url</span><span class="structure">)</span> <span class="operator">=</span> <span class="structure">(</span><span class="word">each</span> <span class="cast">%</span><span class="structure">{</span><span class="symbol">$self</span><span class="operator">-&gt;</span><span class="word">urls</span><span class="structure">}))</span> <span class="structure">{</span><br />&nbsp;&nbsp;<span class="operator">...</span><br />&nbsp;&nbsp;<span class="word">my</span> <span class="symbol">$request</span><span class="structure">;</span>    <br />&nbsp;&nbsp;<span class="symbol">$request</span> <span class="operator">=</span> <span class="word">http_request</span><span class="structure">(</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">GET</span> <span class="operator">=&gt;</span> <span class="symbol">$url</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">timeout</span> <span class="operator">=&gt;</span> <span class="number">2</span><span class="operator">,</span> <span class="comment"># seconds</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">sub</span> <span class="structure">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">my</span> <span class="structure">(</span><span class="symbol">$content</span><span class="operator">,</span> <span class="symbol">$headers</span><span class="structure">)</span> <span class="operator">=</span> <span class="magic">@_</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="symbol">$result</span><span class="operator">-&gt;</span><span class="structure">{</span><span class="symbol">$service_name</span><span class="structure">}</span> <span class="operator">=</span> <span class="symbol">$content</span><span class="structure">;</span><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="core">undef</span> <span class="symbol">$request</span><span class="structure">;</span>                       <span class="comment"># &lt;------------- we add this</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="operator">...</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">}</span><br />&nbsp;&nbsp;<span class="structure">);</span><br />&nbsp;&nbsp;<span class="operator">...</span><br /><span class="structure">}</span><br /><br /><span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">end</span><span class="structure">;</span><br /><span class="keyword">return</span> <span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">recv</span><span class="structure">;</span></code><br />&nbsp;</td></table>

<p>The inner begin and end calls define the individual requests that we want to track in the event loop. For each begin, the AnyEvent event loop will increment a counter. For each end the AnyEvent event loop decrements the counter. Once the counter reaches 0, AnyEvent can set the <code>condvar</code> to <i>ready</i>.</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;<br />6:&nbsp;<br />7:&nbsp;<br />8:&nbsp;<br />9:&nbsp;<br />10:&nbsp;<br />11:&nbsp;<br />12:&nbsp;<br />13:&nbsp;<br />14:&nbsp;<br />15:&nbsp;<br />16:&nbsp;<br />17:&nbsp;<br />18:&nbsp;<br />19:&nbsp;<br />20:&nbsp;<br />21:&nbsp;<br />22:&nbsp;<br />23:&nbsp;<br />24:&nbsp;<br />25:&nbsp;<br />26:&nbsp;<br />27:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="keyword">my</span> <span class="symbol">$cv</span> <span class="operator">=</span> <span class="word">AnyEvent</span><span class="operator">-&gt;</span><span class="word">condvar</span><span class="structure">;</span><br />&nbsp;&nbsp;<br /><span class="keyword">my</span> <span class="symbol">$result</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;<br /><span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">begin</span><span class="structure">(</span><span class="keyword">sub</span> <span class="structure">{</span> <span class="core">shift</span><span class="operator">-&gt;</span><span class="word">send</span><span class="structure">(</span><span class="symbol">$result</span><span class="structure">)</span> <span class="structure">});</span><br /><br /><span class="keyword">while</span> <span class="structure">(</span><span class="keyword">my</span> <span class="structure">(</span><span class="symbol">$service_name</span><span class="operator">,</span> <span class="symbol">$url</span><span class="structure">)</span> <span class="operator">=</span> <span class="structure">(</span><span class="word">each</span> <span class="cast">%</span><span class="structure">{</span><span class="symbol">$self</span><span class="operator">-&gt;</span><span class="word">urls</span><span class="structure">}))</span> <span class="structure">{</span><br />&nbsp;&nbsp;<span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">begin</span><span class="structure">;</span>                       <span class="comment"># &lt;------------- we add this</span><br /><br />&nbsp;&nbsp;<span class="keyword">my</span> <span class="symbol">$request</span><span class="structure">;</span><br />&nbsp;&nbsp;<br />&nbsp;&nbsp;<span class="symbol">$request</span> <span class="operator">=</span> <span class="word">http_request</span><span class="structure">(</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">GET</span> <span class="operator">=&gt;</span> <span class="symbol">$url</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">timeout</span> <span class="operator">=&gt;</span> <span class="number">2</span><span class="operator">,</span> <span class="comment"># seconds</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">sub</span> <span class="structure">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">my</span> <span class="structure">(</span><span class="symbol">$content</span><span class="operator">,</span> <span class="symbol">$headers</span><span class="structure">)</span> <span class="operator">=</span> <span class="magic">@_</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="symbol">$result</span><span class="operator">-&gt;</span><span class="structure">{</span><span class="symbol">$service_name</span><span class="structure">}</span> <span class="operator">=</span> <span class="symbol">$content</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="core">undef</span> <span class="symbol">$request</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">end</span><span class="structure">;</span>                     <span class="comment"># &lt;------------- and we add this</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">}</span><br />&nbsp;&nbsp;<span class="structure">);</span><br /><span class="structure">}</span><br /><br /><span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">end</span><span class="structure">;</span><br /><br /><span class="keyword">return</span> <span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">recv</span><span class="structure">;</span></code><br />&nbsp;</td></table>

<p>And that&#39;s it, we&#39;ve got a working example!</p>

<h3 id="When-should-I-use-Asynchronous-Programming">When should I use Asynchronous Programming?</h3>

<p>An asynchronous solution works best for problems that meet all of the following criteria:</p>

<ul>

<li><p>You need to do many things that could take awhile</p>

</li>
<li><p>You don&#39;t care about the order you do those things in</p>

</li>
</ul>

<p>Given that an asynchronous solution can be hard to read and potentially hard to maintain, you should use metrics to determine if this added complexity really buys you anything.</p>

<h3 id="Next-Improvement:-Lets-create-a-work-queue">Next Improvement: Let&#39;s create a work queue!</h3>

<p>Work queues are good for throttling the work your application has to do, for scheduling when this work needs to happen, and is a good solution for anything that could potentially take a long time thus causing a timeout experience for the end user. To create a work queue, you need a message queue where one part of your application can post messages to (work to be done) and where another part of your application or a separate <i>worker</i> process can access the messages and perform the work.</p>

<p>You can throttle the database load by determining how many messages your worker handles at one time. This could be as simple as a while loop that pauses in between processing. You could also spin up more workers if your message queue gets too long. If you need to do massive updates to lots of records such that you don&#39;t want to do them at a peak time when the database indexes are constantly being updated due to a large number of writes, you can schedule your worker processes to run at an off-peak time. This can be as simple as a perl script you write and then use a cron job to schedule.</p>

<p>In our example, let&#39;s say our users all hit the database the same time every week for these reports. These reports hit the database pretty hard which causes timeouts for other users and reports to fail to complete. Again, before we jump into adding yet more complexity to our technology stack, we need to consider if this solution is the best one for our problem.</p>

<p>Other solutions could be to move our single database instance into a cluster, or to pre-compute the data into predictable date chunks. If we have a table that has a lengthy history we could look at windowing or partitioning of the table to limit the total results the query has to run against. Let&#39;s say in this situation, we don&#39;t have the resources to make changes to the database. Apparently that&#39;s another department and there&#39;s a lengthy red tape process we need to follow in order to get anything done in that regard. While that points to greater systemic problems at our example company, this does often reflect reality and we still need to come up with a solution.</p>

<p>Enter RabbitMQ. RabbitMQ runs as a separate process which the various Perl processes communicate with via AMQP (Advanced Message Queuing Protocol) and is implemented in Erlang. RabbitMQ essentially receives and forwards messages. You could also use Redis and the Redis::Requeue library for the same thing, but RMQ offers us an asynchronous option.</p>

<h3 id="What-does-Asynchronous-Programming-have-to-do-with-RabbitMQ">What does Asynchronous Programming have to do with RabbitMQ?</h3>

<p>Sockets are traditionally a blocking connection. The actual connection attempt blocks until the connection is available. So to connect to RabbitMQ, we would need to wait for the HTTP connection and we would need to be able to respond to error messages. AnyEvent is an asynchronous library and AnyEvent::RabbitMQ is the canonical Perl library for interacting with RabbitMQ.</p>

<p>The reason using an asynchronous connection with RabbitMQ is important is because RabbitMQ sends a heartbeat to determine if the connection is still active. Most web framework applications by their nature are blocking, code is only triggered when a specific request (usually via a URL route) is made.</p>

<p>Once the publisher has established a connection, RabbitMQ can create an exchange. This exchange handles all incoming updates and redistributes them to the available queues. Once the exchange is created, RabbitMQ can send messages.</p>

<p>If the web application does not respond to the RMQ heartbeat, RMQ will hang up on you thereby closing the connection. So unless you want to hang up and reconnect every time you want to send a message to RabbitMQ, you&#39;ll need to double check that your web framework has a way to respond to this heartbeat.</p>

<p>In the example code, I&#39;ve chosen to use Mojolicious because Mojo::IO Loop handles multiple reactor backends.</p>

<h4 id="Step-1:-Replace-the-original-work-section-with-publishing-a-message-to-RabbitMQ">Step 1: Replace the original &ldquo;work&rdquo; section with publishing a message to RabbitMQ</h4>

<p>Some things to think about:</p>

<ul>

<li><p>do you need to keep a record of the queue data?</p>

</li>
<li><p>do you need to recreate the queue if the messages are lost?</p>

</li>
</ul>

<p>First we need to set up our RabbitMQ connection. This is in the <a href="https://github.com/missaugustina/perl-out-of-order/blob/master/worker-queue/bin/main.pl">main.pl</a> file of the worker queue version of the sample code.</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;<br />6:&nbsp;<br />7:&nbsp;<br />8:&nbsp;<br />9:&nbsp;<br />10:&nbsp;<br />11:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="keyword">my</span> <span class="symbol">$cv</span> <span class="operator">=</span> <span class="word">AnyEvent</span><span class="operator">-&gt;</span><span class="word">condvar</span><span class="structure">;</span><br /><br /><span class="keyword">my</span> <span class="symbol">$ar</span> <span class="operator">=</span> <span class="word">AnyEvent::RabbitMQ</span><span class="operator">-&gt;</span><span class="word">new</span><span class="operator">-&gt;</span><span class="word">load_xml_spec</span><span class="structure">()</span><span class="operator">-&gt;</span><span class="word">connect</span><span class="structure">(</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">host</span>       <span class="operator">=&gt;</span> <span class="single">'localhost'</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">port</span>       <span class="operator">=&gt;</span> <span class="number">5672</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">user</span>       <span class="operator">=&gt;</span> <span class="single">'guest'</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">pass</span>       <span class="operator">=&gt;</span> <span class="single">'guest'</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">vhost</span>      <span class="operator">=&gt;</span> <span class="single">'/'</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">on_success</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span> <span class="structure">{</span> <span class="operator">...</span> <span class="structure">}</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="operator">...</span><br /><span class="structure">);</span></code><br />&nbsp;</td></table>

<p>This essentially connects to the message queue and then calls the <code>on_success</code> callback. Inside this <code>on_success</code> callback we then open the channel:</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;<br />6:&nbsp;<br />7:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="word">on_success</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span> <span class="structure">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">my</span> <span class="symbol">$ar</span> <span class="operator">=</span> <span class="core">shift</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="symbol">$ar</span><span class="operator">-&gt;</span><span class="word">open_channel</span><span class="structure">(</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">on_success</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span> <span class="structure">{</span> <span class="operator">...</span> <span class="structure">}</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="operator">...</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">);</span><br /><span class="structure">}</span><span class="operator">,</span></code><br />&nbsp;</td></table>

<p>And inside the <code>on_success</code> callback of the <code>open_channel</code> we have the bit of code that actually puts stuff on the message queue:</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;<br />6:&nbsp;<br />7:&nbsp;<br />8:&nbsp;<br />9:&nbsp;<br />10:&nbsp;<br />11:&nbsp;<br />12:&nbsp;<br />13:&nbsp;<br />14:&nbsp;<br />15:&nbsp;<br />16:&nbsp;<br />17:&nbsp;<br />18:&nbsp;<br />19:&nbsp;<br />20:&nbsp;<br />21:&nbsp;<br />22:&nbsp;<br />23:&nbsp;<br />24:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="word">on_success</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span> <span class="structure">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">my</span> <span class="symbol">$channel</span> <span class="operator">=</span> <span class="core">shift</span><span class="structure">;</span><br /><br /><span class="comment">     # use a named queue &quot;reports&quot;<br /></span>     <span class="symbol">$channel</span><span class="operator">-&gt;</span><span class="word">declare_queue</span><span class="structure">(</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">queue</span> <span class="operator">=&gt;</span> <span class="single">'reports'</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">auto_delete</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">);</span><br /><br /><span class="comment">     # publish (send) to the message queue<br /></span>     <span class="keyword">my</span> <span class="symbol">%publish_args</span> <span class="operator">=</span> <span class="structure">(</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">header</span> <span class="operator">=&gt;</span> <span class="structure">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">content_type</span>    <span class="operator">=&gt;</span> <span class="single">'application/json'</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">}</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">body</span> <span class="operator">=&gt;</span> <span class="word">encode_json</span><span class="structure">(</span><span class="symbol">$params</span><span class="structure">)</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">routing_key</span> <span class="operator">=&gt;</span> <span class="single">'reports'</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">);</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="symbol">$channel</span><span class="operator">-&gt;</span><span class="word">publish</span><span class="structure">(</span><span class="symbol">%publish_args</span><span class="structure">);</span><br /><br /><span class="comment">     # and update the condition variable to say we're done with the<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# queue sending part<br /></span>     <span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">send</span><span class="structure">(</span><span class="double">&quot;Added report request to queue&quot;</span><span class="structure">);</span><br />&nbsp;&nbsp;<span class="structure">}</span><span class="operator">,</span><br />&nbsp;&nbsp;<span class="operator">...</span></code><br />&nbsp;</td></table>

<h4 id="Step-2:-Move-the-work-to-a-worker-process">Step 2: Move the <i>work</i> to a worker process</h4>

<p>Now we&#39;ve got something requesting work, we need a worker on the other end of the message queue actually doing the work.</p>

<p>You can schedule your worker as a cron job which works with RabbitMQ because there isn&#39;t any overstepping if the previous job hasn&#39;t finished yet. You can also use AnyEvent::timer on a loop if you aren&#39;t a fan of cron jobs. There a quite a few options for running your worker process on a schedule, the sample application just uses a simple Perl script with the idea that it would be a cron job.</p>

<p>The worker will need to take a message, process it, then grab the next one. You can have as many of these running as you want depending on your work load. To determine your work load, log metrics and keep an eye on them. Don&#39;t make assumptions that aren&#39;t based on actual data!</p>

<p>We&#39;ll use the <code>consume()</code> method to get the next message in the message queue. Once we get the message, we get the delivery tag for communication with the queue later. The payload is the queue item content. In our example we have this encoded in JSON so we need to decode it to do anything with it. This code can be found in the <a href="https://github.com/missaugustina/perl-out-of-order/blob/master/worker-queue/bin/report_worker.pl">report_worker.pl</a> file.</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;<br />6:&nbsp;<br />7:&nbsp;<br />8:&nbsp;<br />9:&nbsp;<br />10:&nbsp;<br />11:&nbsp;<br />12:&nbsp;<br />13:&nbsp;<br />14:&nbsp;<br />15:&nbsp;<br />16:&nbsp;<br />17:&nbsp;<br />18:&nbsp;<br />19:&nbsp;<br />20:&nbsp;<br />21:&nbsp;<br />22:&nbsp;<br />23:&nbsp;<br />24:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="comment"># connect to the message queue as in the previous example<br /></span><span class="symbol">$ar</span><span class="operator">-&gt;</span><span class="word">open_channel</span><span class="structure">(</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">on_success</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span> <span class="structure">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">my</span> <span class="symbol">$channel</span> <span class="operator">=</span> <span class="core">shift</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="operator">...</span><br /><br /><span class="comment">        # consume (read) messages when they arrive<br /></span>        <span class="symbol">$channel</span><span class="operator">-&gt;</span><span class="word">consume</span><span class="structure">(</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">on_consume</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span> <span class="structure">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">my</span> <span class="structure">(</span><span class="symbol">$message</span><span class="structure">)</span> <span class="operator">=</span> <span class="magic">@_</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">my</span> <span class="symbol">$frame</span> <span class="operator">=</span> <span class="symbol">$message</span><span class="operator">-&gt;</span><span class="structure">{</span><span class="word">deliver</span><span class="structure">}</span><span class="operator">-&gt;</span><span class="word">method_frame</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">my</span> <span class="symbol">$delivery_tag</span> <span class="operator">=</span> <span class="symbol">$frame</span><span class="operator">-&gt;</span><span class="word">delivery_tag</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">my</span> <span class="symbol">$params</span> <span class="operator">=</span> <span class="word">decode_json</span><span class="structure">(</span><span class="symbol">$message</span><span class="operator">-&gt;</span><span class="structure">{</span><span class="word">body</span><span class="structure">}</span><span class="operator">-&gt;</span><span class="word">payload</span><span class="structure">);</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br /><span class="comment">                  # do work specified in %params...<br /></span>                                <br /><span class="comment">                  # confirm that we've done the work and the message<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# queue can drop the message<br /></span>                  <span class="symbol">$channel</span><span class="operator">-&gt;</span><span class="word">ack</span><span class="structure">(</span><span class="word">delivery_tag</span> <span class="operator">=&gt;</span> <span class="symbol">$delivery_tag</span><span class="structure">);</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">}</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">);</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">}</span><span class="operator">,</span><br /><span class="structure">);</span></code><br />&nbsp;</td></table>

<h3 id="The-Gotcha">The Gotcha</h3>

<p>Here&#39;s what the work looks like in the <i>do work</i> section mentioned above. We create a ReportBuilder instance and tell it to build the report.</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="keyword">my</span> <span class="symbol">$report_builder</span> <span class="operator">=</span> <span class="word">Poo::ReportBuilder</span><span class="operator">-&gt;</span><span class="word">new</span><span class="structure">();</span><br /><span class="keyword">my</span> <span class="symbol">$report</span> <span class="operator">=</span> <span class="symbol">$report_builder</span><span class="operator">-&gt;</span><span class="word">build_report</span><span class="structure">(</span><span class="symbol">$params</span><span class="structure">);</span><br /><span class="keyword">my</span> <span class="symbol">$report_json</span> <span class="operator">=</span> <span class="word">encode_json</span><span class="structure">(</span><span class="symbol">$report_data</span><span class="structure">);</span><br /><span class="keyword">my</span> <span class="symbol">$report</span> <span class="operator">=</span> <span class="word">Poo::Report</span><span class="operator">-&gt;</span><span class="word">new</span><span class="structure">(</span><span class="cast">\</span><span class="symbol">%params</span><span class="structure">)</span><span class="operator">-&gt;</span><span class="word">save</span><span class="structure">;</span></code><br />&nbsp;</td></table>

<p>Now here&#39;s the gotcha, and this is an easy mistake to make when you&#39;re first dealing with asynchronous programming: Remember that our <code>build_report</code> function itself uses AnyEvent::HTTP to build the reports - to run more than one web request at a time - and we didn&#39;t write it in a way that plays well with the AnyEvent code we just wrote to deal with the message queue.</p>

<p>If you were to run this code as is, you would get the following error:</p>

<pre><code>  AnyEvent::CondVar: recursive blocking wait attempted at ../lib/Poo/ReportBuilder.pm line 238</code></pre>

<p>For reference, I&#39;ve implemented this in the <a href="https://github.com/missaugustina/perl-out-of-order/tree/master/async">async</a> version of the application in Github with a comment explaining to not do that. Use that code to play around with adding another asynchronous call (say by adding the RabbitMQ code) and seeing what happens.</p>

<p>Remember, we have to call <code>recv</code> at the point in our code when we absolutely need the result to continue: Because our program cannot continue until this method returns something, <code>recv()</code> is considered a blocking function, but we don&#39;t want to block in the middle of generating a report - we need to be going back to the event loop in order to respond to those heartbeats!</p>

<p><code>recv</code> always needs to be at the top level. We need to use callbacks at the highest level, not the <code>condvar</code>. Anything that depends on any return value shouldn&#39;t depend on a variable, it should bind to a callback.</p>

<p>This is also why asynchronous programming can be very confusing and also very hard to maintain and debug. There are some techniques to improve this workflow, including Promises or Futures, but that&#39;s outside of the scope of this article. I do encourage you to research them though as they are reasonable solutions for dealing with callback soup.</p>

<p>Our original build_report method had this code:</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;<br />6:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="keyword">sub</span> <span class="word">build_report</span> <span class="structure">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="operator">...</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">my</span> <span class="symbol">$http_data</span> <span class="operator">=</span> <span class="symbol">$self</span><span class="operator">-&gt;</span><span class="word">_get_data_from_urls</span><span class="structure">(</span> <span class="cast">\</span><span class="symbol">%urls_list</span> <span class="structure">);</span><br /><br /><span class="comment">    # do stuff with $http_data...<br /></span><span class="structure">}</span></code><br />&nbsp;</td></table>

<p>We need to change this to bind to a callback so a caller can manage their own <code>condvar</code> and their own <code>recv</code> call.</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;<br />6:&nbsp;<br />7:&nbsp;<br />8:&nbsp;<br />9:&nbsp;<br />10:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="keyword">sub</span> <span class="word">build_report</span> <span class="structure">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="operator">...</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="symbol">$self</span><span class="operator">-&gt;</span><span class="word">_get_data_from_urls</span><span class="structure">(</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cast">\</span><span class="symbol">%urls_list</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">sub</span> <span class="structure">{</span> <br /><span class="comment">        # do stuff with $http_data...<br /></span>        <span class="operator">...</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">}</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">);</span><br /><span class="structure">}</span></code><br />&nbsp;</td></table>

<p>We&#39;ll alter the <code>_get_data_from_urls()</code> method by removing the <code>recv</code> method and by using the <code>cb</code> method instead. Whenever it completes and something is sent to the <code>condvar</code>, the <code>cb</code> method of the <code>condvar</code> calls the specified function as soon as it completes. The caller is responsible for providing a callback.</p>



<table class='code-listing'><tr><td class='line-numbers'><br /><code>1:&nbsp;<br />2:&nbsp;<br />3:&nbsp;<br />4:&nbsp;<br />5:&nbsp;<br />6:&nbsp;<br />7:&nbsp;<br />8:&nbsp;<br />9:&nbsp;<br />10:&nbsp;<br />11:&nbsp;<br />12:&nbsp;<br />13:&nbsp;<br />14:&nbsp;<br />15:&nbsp;<br />16:&nbsp;<br />17:&nbsp;<br />18:&nbsp;<br />19:&nbsp;<br />20:&nbsp;<br />21:&nbsp;<br />22:&nbsp;<br />23:&nbsp;<br />24:&nbsp;<br />25:&nbsp;<br />26:&nbsp;<br />27:&nbsp;<br />28:&nbsp;<br />29:&nbsp;<br />30:&nbsp;<br />31:&nbsp;<br />32:&nbsp;<br />33:&nbsp;<br />34:&nbsp;<br />35:&nbsp;</code><br />&nbsp;</td><td class='code'><br /><code><span class="keyword">sub</span> <span class="word">_get_data_from_urls</span> <span class="structure">{</span><br />&nbsp;&nbsp;<span class="keyword">my</span> <span class="symbol">$urls</span> <span class="operator">=</span> <span class="core">shift</span><span class="structure">;</span><br />&nbsp;&nbsp;<span class="keyword">my</span> <span class="symbol">$callback</span> <span class="operator">=</span> <span class="core">shift</span><span class="structure">;</span><br /><br />&nbsp;&nbsp;<span class="keyword">my</span> <span class="symbol">$cv</span> <span class="operator">=</span> <span class="word">AnyEvent</span><span class="operator">-&gt;</span><span class="word">condvar</span><span class="structure">;</span><br />&nbsp;&nbsp;<br />&nbsp;&nbsp;<span class="keyword">my</span> <span class="symbol">$result</span><span class="structure">;</span><br /><br />&nbsp;&nbsp;<span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">begin</span><span class="structure">(</span><span class="keyword">sub</span> <span class="structure">{</span> <span class="core">shift</span><span class="operator">-&gt;</span><span class="word">send</span><span class="structure">(</span><span class="symbol">$result</span><span class="structure">)</span> <span class="structure">});</span><br /><br />&nbsp;&nbsp;<span class="keyword">while</span> <span class="structure">(</span><span class="keyword">my</span> <span class="structure">(</span><span class="symbol">$customerid</span><span class="operator">,</span> <span class="symbol">$urls</span><span class="structure">)</span> <span class="operator">=</span> <span class="structure">(</span><span class="word">each</span> <span class="cast">%</span><span class="structure">{</span><span class="symbol">$urls</span><span class="structure">}))</span> <span class="structure">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span> <span class="keyword">my</span> <span class="symbol">$service_name</span> <span class="structure">(</span><span class="word">keys</span> <span class="cast">%</span><span class="structure">{</span><span class="symbol">$urls</span><span class="structure">})</span> <span class="structure">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">begin</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">my</span> <span class="symbol">$request</span><span class="structure">;</span><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="symbol">$request</span> <span class="operator">=</span> <span class="word">http_request</span><span class="structure">(</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">GET</span> <span class="operator">=&gt;</span> <span class="symbol">$urls</span><span class="operator">-&gt;</span><span class="structure">{</span><span class="symbol">$service_name</span><span class="structure">}</span><span class="operator">,</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="word">timeout</span> <span class="operator">=&gt;</span> <span class="number">2</span><span class="operator">,</span> <span class="comment"># seconds</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">sub</span> <span class="structure">{</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">my</span> <span class="structure">(</span><span class="symbol">$body</span><span class="operator">,</span> <span class="symbol">$hdr</span><span class="structure">)</span> <span class="operator">=</span> <span class="magic">@_</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="symbol">$result</span><span class="operator">-&gt;</span><span class="structure">{</span><span class="symbol">$customerid</span><span class="structure">}</span><span class="operator">-&gt;</span><span class="structure">{</span><span class="symbol">$service_name</span><span class="structure">}</span> <span class="operator">=</span> <span class="symbol">$body</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">end</span><span class="structure">;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">}</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">);</span><br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="structure">}</span><br />&nbsp;&nbsp;<span class="structure">}</span><br />&nbsp;&nbsp;<br />&nbsp;&nbsp;<span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">end</span><span class="structure">;</span><br />&nbsp;&nbsp;<br /><span class="comment">  # this replaces &quot;my $http_result = $cv-&gt;recv;&quot;               # &lt;--<br />&nbsp;&nbsp;# now the condition variable calls the callback when it      # &lt;-- new<br />&nbsp;&nbsp;# reaches the ready state                                    # &lt;-- code<br /></span>  <span class="symbol">$cv</span><span class="operator">-&gt;</span><span class="word">cb</span><span class="structure">(</span><span class="symbol">$callback</span><span class="structure">);</span>                                          <span class="comment"># &lt;--</span><br /><span class="structure">}</span></code><br />&nbsp;</td></table>

<h3 id="Sample-Code-Available">Sample Code Available</h3>

<p>Again, I want to reiterate, I have <a href="https://github.com/missaugustina/perl-out-of-order/">sample code</a> available for you to download and play with. Please experiment with this, try setting different values and using your debugger to step through the code to see when things get called and what values they produce. Asynchronous programming isn&#39;t something you really understand until you have to use it, and it&#39;s worth understanding.</p>

<h2 id="See-Also">See Also</h2>

<ul>

<li><p><a href="https://metacpan.org/module/AnyEvent">AnyEvent</a></p>

</li>
<li><p><a href="http://github.com/missaugustina/perl-out-of-order">Sample code</a></p>

</li>
<li><p><a href="https://www.youtube.com/watch?v=VYBLCvMu_pA">YAPC::NA talk video</a></p>

</li>
<li><p><a href="https://metacpan.org/module/AnyEvent::HTTP">AnyEvent::HTTP</a></p>

</li>
<li><p><a href="https://metacpan.org/module/AnyEvent::RabbitMQ">AnyEvent::RabbitMQ</a></p>

</li>
<li><p><a href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a></p>

</li>
<li><p><a href="https://metacpan.org/module/Promises">Promises</a></p>

</li>
<li><p><a href="https://metacpan.org/module/Future">Future</a></p>

</li>
</ul>

</div>

<div id='author'>
<img alt='Gravatar Image' style='vertical-align:middle' src=http://www.gravatar.com/avatar/99af8c2ec04ac791f51f2b8f10b77723?r=g&s=80&d=retro />
This article contributed by: Augustina Ragwitz &lt;aragwitz@gmail.com&gt;
</div>


<ul id="pager">
    <li class="previous"><a title="CLDR TL;DR" href="2014-12-23.html">Previous</a></li>

    <li class="next"><a title="So here it is Merry Christmas" href="2014-12-25.html">Next</a></li>
</ul>
<div style="clear: both"></div>

        </div>
    </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-27056407-1");
pageTracker._trackPageview();
} catch(err) {}</script>
</body>
</html>



